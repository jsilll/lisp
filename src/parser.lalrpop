use ast::expression::Expr;
use ast::statement::Statement;
use lexer::{Token, Keyword, Literal, Operator, Separator};

grammar<'i>(input: &'i str);

pub Program: Program = {
 "{" <Statements> "}" => Program::new(<>)
}

Statement: Statement = {
    "let" <Identifier> "=" <Expr> ";" => Statement::new_definition(<>),
    <Identifier> "=" <Expr> ";" => Statement::new_assignment(<>)
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    "(" <Expr> ")"
};

Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Statements: Vec<Statement> = {
    Statement => vec![<>],
    Statements Statement => append(<>),
};


extern {
    type Error = ();
    type Location = usize;
    
    enum Token<'i> {
        "Literal" => Literal,
        "Operator" => Operator,

        "Let" => Keyword::Let,

        "(" => Separator::LeftParen,
        ")" => Separator::RightParen,
    }
}